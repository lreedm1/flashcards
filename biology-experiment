from itertools import count
import os
import re
from titlecase import titlecase
import string as punctuation
import time

dataset = "/Users/reed/Documents/Nightly/bio test set.txt"
dictionary = "/Users/reed/Documents/Nightly/dictionary.txt"
directory = "/Users/reed/Library/Mobile Documents/iCloud~md~obsidian/Documents/biology test"

def user_input(prompt, responses, error_message): # Ask the user a question and return their response
    while True:
        x = input(prompt)
        if x in responses:
            return x
        elif x == 'q':
            quit()
        else:
            print(error_message)
            continue


def titlecase_plus(string): # run the string through titlecase but allow for acronyms
    split_on_space = re.split('\s+', string) # split the string on spaces
    acronyms = []
    for i in range(len(split_on_space)): 
        if split_on_space[i].upper() == split_on_space[i]: # if the word is all caps, add it to the acronyms list
            length = len(split_on_space[i])
            start = string.find(split_on_space[i])
            acronyms.append([start, start + length, split_on_space[i]])
        
    string_titlecase = titlecase(string)
    for i in acronyms: # replace the acronyms with the original capitalization
        string_titlecase = string_titlecase[:i[0]] + i[2] + string_titlecase[i[1]:]

    return string_titlecase


def make_directory(path, file):
    # read the file and save it to a list called contents
    with open(dataset, 'r') as f:
        contents = f.read()
    
    # the file is a list of terms and definitions seperated by ';;' and ';;;' respectively
    # split the contents into a list of lists
    # first, replace all empty terms with '*****'
    contents = contents.replace(';;;;;', '*****')
    contents = contents.split(";;;")
    # subdivide contents by ';;'
    contents = [x.split(';;') for x in contents]
    saved_contents = []
    # format the contents of the list
    for i in range(len(contents)):
        # print the contents to make sure regex is working
        try:
            # if the contents are less than two characters or contain the code "*****", skip the term
            if len(contents[i][1]) < 2 or "*****" in contents[i][1] or "*****" in contents[i][0]:
                print(f'{contents[i]} is to short or got flagged for being blank')
                continue
        except IndexError:
            print(f'{contents[i]} is too short')
            continue # skip the code below the try

        
        title = titlecase_plus(contents[i][0]) # titlecase the term
        title = title.replace("/", "or") # replace slashes with 'or'
        title = title.replace('\\', 'or') # replace backslashes with 'or'

        # if the content does not contain adjacanet capital letters, capitalize the first letter
        for a in range(len(title)-1):
            if title[a].isupper() and title[a+1].isupper():
                break
        else:
            title = title[0].upper() + title[1:]
        
        definition = contents[i][1]
        if definition[-1] == ".": # if definition ends with a period, remove it
            definition = definition[:-1]

        print(title + " created")

        saved_contents.append([title, definition]) 
        # create a card for each term
        # it is not written to disk until write_cards is called
        
        # convert saved_contents to a tuple so it is not overwritten

    return saved_contents

def normalize(string, mode):
    '''
    mode 0 = term
    mode 1 = definition
    '''
    if mode == 0:
        string = string.lower()
        # split the string if it contaiins text within parentheses
        if "(" in string:
            x = [string.find("("), string.find(")")]
            string = [string[:x[0]] + string[x[1]+1:], string[x[0]+1:x[1]]]
            #input(f'string: {string}')
        else:
            string = [string]
    if mode == 1:
        string = string.lower()
        string = " " + string + " "
        string = string.replace("/", "or")
        string = string.replace('\\', 'or')
        # replae all punctuation with a space
        for i in punctuation.punctuation:
            string = string.replace(i, " ")

    return string

def make_connections(terms):
    ''''
    1. Make a list of all the terms
    2. Make a list of all the definitions
    3. Make a list of all the normalized terms
    4. Make a list of all the normalized definitions
    5. Search the normalized definitions for the normalized terms and add the index of the term to the term's connections list
    6. Reformat the connections list to be a list of lists in the format [definition index, [term to append index, term to append index]]
    7. Append the term's connections list to the original term list using the format "\n References:" + " [" + str(index) + "]" 
    '''
    # make a list of all the terms and all the definitions
    print("Making connections...")
    terms_list = []
    definitions_list = []
    for i in range(len(terms)):
        terms_list.append(terms[i][0])
        definitions_list.append(terms[i][1])
    # make a list of all the normalized terms and all the normalized definitions
    normalized_terms_list = []
    normalized_definitions_list = []
    for i in range(len(terms)):
        normalized_terms_list.append(normalize(terms[i][0], 0))
        normalized_definitions_list.append(normalize(terms[i][1], 1))

    # make a list of all the normalized terms and all the normalized definitions
    term_connections = []
    term_length = len(terms_list)
    print("Searching for connections...")
    for i in range(term_length):
        for j in range(term_length):
            if i == j:
                continue
            for k in normalized_terms_list[i]:
                # add spaces to the beginning and end of the term to make sure the term is found in the definition
                k = " " + k + " "
                l = " " + str(normalized_definitions_list[j]) + " "
                if l.find(k) != -1:
                    term_connections.append([i, j])
                    break

    # reformat the connections list to be a list of lists in the format [definition index, [term to append index, term to append index]]
    connections_list = []
    print("Reformatting connections...")
    for i in range(len(term_connections)):
        # determine if the definition index is already in the connections list
        for j in range(len(connections_list)):
            if term_connections[i][1] == connections_list[j][0]:
                connections_list[j][1].append(term_connections[i][0])
                break
        else:
            connections_list.append([term_connections[i][1], [term_connections[i][0]]])

    # add the connections to the terms
    for i in range(len(connections_list)):
        print(f'{connections_list[i]}')
        terms[connections_list[i][0]][1] += '\nReferences:'
        for j in range(len(connections_list[i][1])):

            terms[connections_list[i][0]][1] += f" [[{terms[connections_list[i][1][j]][0]}]]"
        #input(f' terms[{connections_list[i][0]}]: {terms[connections_list[i][0]]}')


    for i in range(len(terms)):
        print()
        print(terms[i][0])
        print(terms[i][1])
    
    return terms
        
def weight(cards, dictionary, directory): 
    # convert cards (which is a tuple) to a list of lists called word_list
    x = cards
    word_list = list(cards)

    with open(dictionary, 'r') as f:
        dictionary = f.read()

    # every few lines, the dictionary contains a line that starts with "#! comment", remove those lines
    dictionary = [x for x in dictionary.split("\n") if not x.startswith("#!")]
    # lowercase all words in the dictionary
    for i in range(len(dictionary)):
        dictionary[i] = dictionary[i].lower()

   # turn terms into a list of words, and use terms to make a count of how often each word appears
    words = []
    for i in range(len(word_list)):
        # split all of terms [i][1] into a list of words and add them to the words list
        word_list[i][0] = word_list[i][0].split(" ")
        word_list[i][1] = word_list[i][1].split(" ")

        for j in range(len(word_list[i][1])):
            words.append(word_list[i][1][j].lower())
        for j in range(len(word_list[i][0])):
            words.append(word_list[i][0][j].lower())
    # remove puncuation from the words list
    punctuation = string.punctuation
    for i in range(len(words)):
        for j in punctuation:
            words[i] = words[i].replace(j, "")

    word_list = []
    count = []
    for i in range(len(words)):
        if words[i] not in word_list:
            word_list.append(words[i])
            count.append(1)
        else:
            count[word_list.index(words[i])] += 1


    # zip terms and count together, and sort by count
    terms_counted = list(zip(word_list, count))
    terms_counted.sort(key=lambda x: x[1], reverse=True)

    # turn the terms_counted list into a dictionary
    message = ""

    message += "The most common words are:\n"
    # add the terms to the message with their counts surrounded by parentheses
    for i in range(len(terms_counted)):
      message += f'({terms_counted[i][0]}, {terms_counted[i][1]}) '

    terms_in_dictionary = []
    for i in range(len(terms_counted)):
        if terms_counted[i][0] in dictionary:
            terms_in_dictionary.append(terms_counted[i][0])
    
    message += "\n\nThe most common words from this set in the dictionary are:\n"


    # write the terms_counted to a file called 'card_statistics.md'
    with open(directory + '/card_statistics.md', 'w') as f:
        f.write(message)

    return x
    


def read_directory(directory):
    terms = []
    for filename in os.listdir(directory):
        with open(directory + "/" + filename, 'r') as f:
            contents = f.read()
        terms.append([filename[:-3], contents])
    return terms

def write_cards(cards, directory):
    print("writing cards")
    #input("Press enter to continue")
    for i in range(len(cards)):
        with open(directory + "/" + cards[i][0] + ".md", "w") as f:
            f.write(cards[i][1])
        print(f'{cards[i][0]} written to disk')
    
def remove_duplicates(cards):
    # remove all duplicate terms by adding the next term to the first term, then delete the second term
    y = 0 # y accounts for the number of duplicates removed
    for i in range(len(cards)):
        x = 0 # x functions as a counter for the number of times the first term has been added to the second term
        for j in range(i + 1, len(cards)):
            j -= x # j is the index of the second term, and x is the number of times the first term has been added to the second term
            if cards[i][0] == cards[j][0]:
                # add "Definition 1:\n" to "Term 1", then "Definition 2\n" to "Term 1"
                
                if x == 0:
                    cards[i][1] = "Definition 1:\n" + cards[i][1]
                cards[i][1] += "\n\n" + "Definition " + str(x + 2) + ":\n" + cards[j][1]
                # remove the second term from the list
                print(f'Removing {cards[j][0]}')
                cards.pop(j)

                x += 1
                y += 1
    return cards


def main():
    response = user_input('Has the test set been created? (Y/n)\n', ['y', 'n', ''], 'Please enter a command')
    if response == 'y' or response == "":
        cards = read_directory(directory)
    else:
        cards = make_directory(directory, dataset)

    # remove duplicate cards
    cards = remove_duplicates(cards)
    
    # = make_connections(terms) will append weights to the terms list once the function is 
   
    #cards = weight(cards, dictionary, directory)
    cards = make_connections(cards)

    write_cards(cards, directory)
    
    

main()